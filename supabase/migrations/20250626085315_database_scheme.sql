-- ENUM TYPES
CREATE TYPE option_type_enum AS ENUM ('open', 'fixed');
CREATE TYPE payment_mode_enum AS ENUM ('cash', 'cashless', 'hybrid');
CREATE TYPE order_status_enum AS ENUM ('pending', 'confirmed', 'cancelled');

-- VERSIONING FUNCTION
CREATE OR REPLACE FUNCTION update_version_and_timestamp()
RETURNS trigger AS $$
BEGIN
  NEW.version := OLD.version + 1;
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- PROFILES
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users (id) ON DELETE CASCADE,
  username TEXT,
  business_name TEXT,
  user_address TEXT,
  business_address TEXT,
  phone_no TEXT,
  email TEXT,
  business_email TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  business_phone_no TEXT,
  deleted BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User can insert own profile" ON public.profiles FOR INSERT WITH CHECK (id = auth.uid());
CREATE POLICY "User can update own profile" ON public.profiles FOR UPDATE USING (id = auth.uid());
CREATE POLICY "User can select own profile" ON public.profiles FOR SELECT USING (id = auth.uid());

-- CATEGORY
CREATE TABLE public.category (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  image_url TEXT,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  version INTEGER DEFAULT 1,
  deleted_at TIMESTAMPTZ,
  deleted BOOLEAN DEFAULT false,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  UNIQUE (user_id, name)
);

ALTER TABLE public.category ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert own category" ON public.category FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update own category" ON public.category FOR UPDATE USING (user_id = auth.uid());
CREATE POLICY "User select own category" ON public.category FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_user_id_category() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_category BEFORE INSERT ON public.category FOR EACH ROW EXECUTE FUNCTION set_user_id_category();
CREATE TRIGGER trg_update_category_version BEFORE UPDATE ON public.category FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();

-- SUBCATEGORY
CREATE TABLE public.subcategory (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  image_url TEXT,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  version INTEGER DEFAULT 1,
  deleted_at TIMESTAMPTZ,
  deleted BOOLEAN DEFAULT false,
  category_id BIGINT REFERENCES public.category(id),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  UNIQUE (user_id, name)
);

ALTER TABLE public.subcategory ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert subcategory" ON public.subcategory FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update subcategory" ON public.subcategory FOR UPDATE USING (user_id = auth.uid());
CREATE POLICY "User select subcategory" ON public.subcategory FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_user_id_subcategory() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_subcategory BEFORE INSERT ON public.subcategory FOR EACH ROW EXECUTE FUNCTION set_user_id_subcategory();
CREATE TRIGGER trg_update_subcategory_version BEFORE UPDATE ON public.subcategory FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();

-- ITEM
CREATE TABLE public.item (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  image_url TEXT,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  version INTEGER DEFAULT 1,
  deleted_at TIMESTAMPTZ,
  deleted BOOLEAN DEFAULT false,
  subcategory_id BIGINT REFERENCES public.subcategory(id),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  UNIQUE (user_id, name)
);

ALTER TABLE public.item ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert item" ON public.item FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update item" ON public.item FOR UPDATE USING (user_id = auth.uid());
CREATE POLICY "User select item" ON public.item FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_user_id_item() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_item BEFORE INSERT ON public.item FOR EACH ROW EXECUTE FUNCTION set_user_id_item();
CREATE TRIGGER trg_update_items_version BEFORE UPDATE ON public.item FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();

-- OPTION
CREATE TABLE public.option (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  item_id BIGINT NOT NULL REFERENCES public.item(id),
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  version INTEGER DEFAULT 1,
  deleted_at TIMESTAMPTZ,
  deleted BOOLEAN DEFAULT false,
  base_unit_price NUMERIC(18,6),
  price_unit_saved TEXT,
  type option_type_enum,
  unit_tag TEXT,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  UNIQUE (item_id, name)
);

ALTER TABLE public.option ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert option" ON public.option FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update option" ON public.option FOR UPDATE USING (user_id = auth.uid());
CREATE POLICY "User select option" ON public.option FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_user_id_option() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_option BEFORE INSERT ON public.option FOR EACH ROW EXECUTE FUNCTION set_user_id_option();
CREATE TRIGGER trg_update_options_version BEFORE UPDATE ON public.option FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();

-- ORDER
CREATE TABLE public."order" (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT now(),
  order_no INTEGER NOT NULL,
  order_name TEXT,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  discount NUMERIC(10,2),
  payment_mode payment_mode_enum,
  cash_amount NUMERIC(10,2),
  cashless_amount NUMERIC(10,2),
  status order_status_enum DEFAULT 'pending',
  version INTEGER DEFAULT 1,
  updated_at TIMESTAMPTZ DEFAULT now(),
  deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMPTZ
);

ALTER TABLE public."order" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert order" ON public."order" FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update pending order" ON public."order" FOR UPDATE USING (user_id = auth.uid() AND status = 'pending');
CREATE POLICY "User select own order" ON public."order" FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_order_user_id() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION set_order_no_per_day() RETURNS trigger AS $$
DECLARE
  next_order_no INTEGER;
BEGIN
  SELECT COALESCE(MAX(order_no), 0) + 1 INTO next_order_no
  FROM public."order"
  WHERE user_id = NEW.user_id AND DATE(created_at) = DATE(NEW.created_at);
  NEW.order_no := next_order_no;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_order BEFORE INSERT ON public."order" FOR EACH ROW EXECUTE FUNCTION set_order_user_id();
CREATE TRIGGER trg_set_order_no BEFORE INSERT ON public."order" FOR EACH ROW EXECUTE FUNCTION set_order_no_per_day();
CREATE TRIGGER trg_update_order_version BEFORE UPDATE ON public."order" FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();

-- ORDER DETAIL
CREATE TABLE public.order_detail (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id BIGINT NOT NULL REFERENCES public."order"(id),
  option_id BIGINT NOT NULL REFERENCES public."option"(id),
  price_unit_save TEXT, -- CHANGED FROM NUMERIC TO TEXT
  base_price NUMERIC(10,2),
  unit_tag TEXT,
  quantities NUMERIC(10,3),
  sold_option_name TEXT,
  version INTEGER DEFAULT 1,
  updated_at TIMESTAMPTZ DEFAULT now(),
  deleted BOOLEAN DEFAULT false,
  deleted_at TIMESTAMPTZ,
  user_id UUID NOT NULL REFERENCES auth.users(id)
);

ALTER TABLE public.order_detail ENABLE ROW LEVEL SECURITY;
CREATE POLICY "User insert order details" ON public.order_detail FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "User update order details if order is pending" ON public.order_detail FOR UPDATE USING (
  user_id = auth.uid() AND EXISTS (
    SELECT 1 FROM public."order" o
    WHERE o.id = order_detail.order_id AND o.status = 'pending'
  )
);
CREATE POLICY "User select own order details" ON public.order_detail FOR SELECT USING (user_id = auth.uid());

CREATE FUNCTION set_user_id_order_details() RETURNS trigger AS $$
BEGIN
  NEW.user_id := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_user_id_order_details BEFORE INSERT ON public.order_detail FOR EACH ROW EXECUTE FUNCTION set_user_id_order_details();
CREATE TRIGGER trg_update_order_details_version BEFORE UPDATE ON public.order_detail FOR EACH ROW EXECUTE FUNCTION update_version_and_timestamp();